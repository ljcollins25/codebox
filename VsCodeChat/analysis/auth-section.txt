\u274C Error: ${_ instanceof Error?_.message:String(_)}`)}finally{this._pendingPrompt=void 0,c.dispose()}}addUserMessage(t){this._sdkSession.emit("user.message",{content:t})}addUserAssistantMessage(t){this._sdkSession.emit("assistant.message",{messageId:`msg_${Date.now()}`,content:t})}getSelectedModelId(){return this._sdkSession.getSelectedModel()}getChatHistory(){let t=this._sdkSession.getEvents(),r=a=>this.copilotCLISDK.getRequestId(a);return A$t(this.sessionId,t,r,this._delegationSummaryService)}async requestPermission(t,r,a,o,s){if(t.kind==="read"){let u=Fn.file(t.path);if(o&&lu.isEqualOrParent(u,Fn.file(o)))return this.logService.trace(`[CopilotCLISession] Auto Approving request to read file in working directory ${t.path}`),{kind:"approved"};if(this.workspaceService.getWorkspaceFolder(u))return this.logService.trace(`[CopilotCLISession] Auto Approving request to read workspace file ${t.path}`),{kind:"approved"}}let c=t.toolCallId?a(t.toolCallId):void 0,l=c?jj(c):void 0,d=l&&l.length?l[0]:void 0;if(o&&t.kind==="write"&&d&&c){let u=this.workspaceService.getWorkspaceFolder(d),p=!this.workspaceService.getWorkspaceFolder(Fn.file(o))&&lu.isEqualOrParent(d,Fn.file(o)),m=!1;if(this._options.isolationEnabled&&p&&(m=!0),!m&&u&&!await S$t(this.instantiationService,t,c)&&(m=!0),m)return this.logService.trace(`[CopilotCLISession] Auto Approving request ${d.fsPath}`),c&&this._stream&&(this.logService.trace(`[CopilotCLISession] Starting to track edit for toolCallId ${c.toolCallId} & file ${d.fsPath}`),await r.trackEdit(c.toolCallId,[d],this._stream)),{kind:"approved"}}try{let u=await this.waitForPermissionHandler(t);if(!u)return this.logService.warn(`[CopilotCLISession] No permission handler registered, denying request for ${t.kind} permission.`),{kind:"denied-interactively-by-user"};if(await u(t,c,s))return d&&c&&this._stream&&(this.logService.trace(`[CopilotCLISession] Starting to track edit for toolCallId ${c.toolCallId} & file ${d.fsPath}`),await r.trackEdit(c.toolCallId,[d],this._stream)),{kind:"approved"}}catch(u){this.logService.error(`[CopilotCLISession] Permission request error: ${u}`)}finally{this._permissionRequested=void 0}return{kind:"denied-interactively-by-user"}}async waitForPermissionHandler(t){if(!this._permissionHandler){this._permissionRequested=t,this._onPermissionRequested.fire(t);let r=this.add(new lt);await Br.toPromise(this._permissionHandlerSet.event,r),r.dispose(),this._permissionRequested=void 0}return this._permissionHandler}};Hj=I([h(2,ne),h(3,Qe),h(4,eI),h(5,U),h(6,AT)],Hj);var D$t=j(Ut());var B$t="github-enterprise.uri",cQ=class{constructor(e,t,r){this.configurationService=e;this.authenticationService=t;this.logService=r;let a=Br.chain(e.onDidChangeConfiguration,c=>c.filter(l=>l.affectsConfiguration(V.GitHubMcpToolsets.fullyQualifiedId)?(r.debug("GitHubMcpDefinitionProvider: Configuration change affects GitHub MCP toolsets."),!0):l.affectsConfiguration(V.GitHubMcpReadonly.fullyQualifiedId)?(r.debug("GitHubMcpDefinitionProvider: Configuration change affects GitHub MCP readonly mode."),!0):l.affectsConfiguration(V.GitHubMcpLockdown.fullyQualifiedId)?(r.debug("GitHubMcpDefinitionProvider: Configuration change affects GitHub MCP lockdown mode."),!0):l.affectsConfiguration(V.Shared.AuthProvider.fullyQualifiedId)?(r.debug("GitHubMcpDefinitionProvider: Configuration change affects GitHub auth provider."),!0):l.affectsConfiguration(B$t)?(r.debug("GitHubMcpDefinitionProvider: Configuration change affects GitHub Enterprise URL."),!0):!1).map(()=>{})),o=!!this.authenticationService.permissiveGitHubSession,s=Br.chain(this.authenticationService.onDidAuthenticationChange,c=>c.filter(()=>{let l=o;return o=!!this.authenticationService.permissiveGitHubSession,l!==o}).map(()=>{this.logService.debug(`GitHubMcpDefinitionProvider: Permissive GitHub session availability changed: ${o}`)}));this.onDidChangeMcpServerDefinitions=Br.any(a,s)}get toolsets(){return this.configurationService.getConfig(V.GitHubMcpToolsets)}get readonly(){return this.configurationService.getConfig(V.GitHubMcpReadonly)}get lockdown(){return this.configurationService.getConfig(V.GitHubMcpLockdown)}get gheConfig(){return this.configurationService.getNonExtensionConfig(B$t)}getGheUri(){let e=this.gheConfig;if(!e)throw new Error("GitHub Enterprise URI is not configured.");let t=_e.parse(e).with({path:"/mcp/"});return t.with({authority:`copilot-api.${t.authority}`})}provideMcpServerDefinitions(){let e=vF(this.configurationService),t=this.toolsets.sort().join(","),r=this.readonly,a=this.lockdown,o=!!this.authenticationService.permissiveGitHubSession,s=e==="github-enterprise"?{label:"GitHub Enterprise",uri:this.getGheUri()}:{label:"GitHub",uri:_e.parse("https://api.githubcopilot.com/mcp/")},c={},l;return o?(l=t.length?t:"0",t.length>0&&(c["X-MCP-Toolsets"]=t),r&&(c["X-MCP-Readonly"]="true",l+="|readonly"),a&&(c["X-MCP-Lockdown"]="true",l+="|lockdown")):l="signedout",[{...s,headers:c,version:l}]}async resolveMcpServerDefinition(e,t){let r=await this.authenticationService.getGitHubSession("permissive",{createIfNone:{detail:D$t.t("Additional permissions are required to use GitHub MCP Server")}});if(!r)throw new Error("Authentication required");return e.headers.Authorization=`Bearer ${r.accessToken}`,e}};cQ=I([h(0,Ce),h(1,et),h(2,ne)],cQ);var n1e=de("ICopilotCLIMCPHandler"),h3=n=>typeof n=="object"&&n!==null,R$t=n=>{if(!Array.isArray(n))return;let e=n.filter(t=>typeof t=="string");return e.length?e:void 0},P$t=n=>{if(!h3(n))return;let e=Object.entries(n);if(e.every(([,t])=>typeof t=="string"))return Object.fromEntries(e)},Wj=class{constructor(e,t,r,a){this.logService=e;this.workspaceService=t;this.authenticationService=r;this.configurationService=a}async loadMcpConfig(e){if(!this.configurationService.getConfig(V.Advanced.CLIMCPServerEnabled))return;let t={},r=this.getWorkspaceFolder(e);return r&&await this.loadConfigFromWorkspace(r,t),await this.addBuiltInGitHubServer(t),Object.keys(t).length>0?t:void 0}getWorkspaceFolder(e){if(e){let r=this.workspaceService.getWorkspaceFolders(),a=this.workspaceService.getWorkspaceFolder(e)??r.find(o=>e.fsPath.startsWith(o.fsPath));return a||e}let t=this.workspaceService.getWorkspaceFolders();if(t.length===0){this.logService.trace("[CopilotCLIMCPHandler] No workspace folders found.");return}return t[0]}async loadConfigFromWorkspace(e,t){let r=yC(e,".vscode","mcp.json");try{let a=await this.workspaceService.fs.readFile(r),o=new TextDecoder().decode(a);await this.parseAndProcessConfig(o,e.fsPath,t)}catch(a){this.logService.trace(`[CopilotCLIMCPHandler] Failed to load MCP config file: ${a}`)}}async parseAndProcessConfig(e,t,r){let a=[],o=mh(e,a,{allowTrailingComma:!0,disallowComments:!1});if(a.length>0){let{error:c}=a[0],l=sQt(c);this.logService.warn(`[CopilotCLIMCPHandler] Failed to parse MCP config ${l}.`);return}let s=this.extractServersFromConfig(o);s&&this.processServerConfigs(s,t,r)}extractServersFromConfig(e){if(!h3(e))return;if(h3(e.servers))return e.servers;let t=e.mcp;if(h3(t)&&h3(t.servers))return t.servers;if(h3(e.mcpServers))return e.mcpServers}processServerConfigs(e,t,r){for(let[a,o]of Object.entries(e)){if(!h3(o)){this.logService.warn(`[CopilotCLIMCPHandler] Ignoring invalid MCP server definition "${a}".`);continue}let s=this.processServerConfig(o,a,t);s&&(r[a]=s)}}processServerConfig(e,t,r){let a=typeof e.type=="string"?e.type:void 0,o=R$t(e.tools),s=o&&o.length>0?o:["*"];if(!a||a==="local"||a==="stdio")return this.processLocalServerConfig(e,t,s,r);if(a==="http"||a==="sse")return this.processRemoteServerConfig(e,t,a,s);this.logService.warn(`[CopilotCLIMCPHandler] Unsupported MCP server type "${a}" for "${t}".`)}processLocalServerConfig(e,t,r,a){let o=typeof e.command=="string"?e.command:void 0;if(!o){this.logService.warn(`[CopilotCLIMCPHandler] Skipping MCP local server "${t}" due to missing command.`);return}let s=typeof e.type=="string"&&e.type==="stdio"?"stdio":"local",c=R$t(e.args)??[],l=P$t(e.env)??{},d=typeof e.cwd=="string"?e.cwd.replace("${workspaceFolder}",a):void 0,u={type:s,command:o,args:c,tools:r,env:l};return d&&(u.cwd=d),u}processRemoteServerConfig(e,t,r,a){let o=typeof e.url=="string"?e.url:void 0;if(!o){this.logService.warn(`[CopilotCLIMCPHandler] Skipping MCP remote server "${t}" due to missing url.`);return}let s=P$t(e.headers)??{};return{type:r,url:o,headers:s,tools:a}}async addBuiltInGitHubServer(e){try{if(e.github)return;let t=new cQ(this.configurationService,this.authenticationService,this.logService),r=t.provideMcpServerDefinitions();if(!r||r.length===0){this.logService.trace("[CopilotCLIMCPHandler] No GitHub MCP server definitions available.");return}let a=r[0],o=await t.resolveMcpServerDefinition(a,{});e.github={type:"http",url:o.uri.toString(),tools:["*"],isDefaultServer:!0,headers:o.headers},this.logService.trace("[CopilotCLIMCPHandler] Added built-in GitHub MCP server via definition provider.")}catch(t){this.logService.warn(`[CopilotCLIMCPHandler] Failed to add built-in GitHub MCP server: ${t}`)}}};Wj=I([h(0,ne),h(1,Qe),h(2,et),h(3,Ce)],Wj);var Q$t="github.copilot.cli.workspaceSessionFile",b3=de("ICopilotCLISessionService"),akr=300*1e3,Zj=class extends pe{constructor(t,r,a,o,s,c,l){super();this.logService=t;this.copilotCLISDK=r;this.instantiationService=a;this.nativeEnv=o;this.fileSystem=s;this.mcpHandler=c;this.agents=l;this._sessionWrappers=new Em;this._onDidChangeSessions=new Lt;this.onDidChangeSessions=this._onDidChangeSessions.event;this.sessionTerminators=new Em;this.sessionMutexForGetSession=new Map;this.monitorSessionFiles(),this._sessionManager=new Xn(async()=>{let{internal:d}=await this.copilotCLISDK.getPackage();return new d.LocalSessionManager({logger:Ise(this.logService)})}),this._sessionTracker=this.instantiationService.createInstance(_ce)}monitorSessionFiles(){try{let t=yC(this.nativeEnv.userHome,".copilot","session-state"),r=this._register(this.fileSystem.createFileSystemWatcher(new sd(t,"*.jsonl")));this._register(r.onDidCreate(()=>this._onDidChangeSessions.fire()))}catch(t){this.logService.error(`Failed to monitor Copilot CLI session files: ${t}`)}}async getSessionManager(){return this._sessionManager.value}async getAllSessions(t){return this._getAllSessionsProgress||(this._getAllSessionsProgress=this._getAllSessions(t)),this._getAllSessionsProgress.finally(()=>{this._getAllSessionsProgress=void 0})}async _getAllSessions(t){try{let r=await Pt(this.getSessionManager(),t),a=await Pt(r.listSessions(),t);await this._sessionTracker.initialize(a.map(d=>d.sessionId));let o=Rn(await Promise.all(a.map(async d=>{if(!this._sessionTracker.shouldShowSession(d.sessionId))return;let u=d.sessionId,p=d.startTime.getTime(),m=d.modifiedTime.getTime(),A=d.summary?eXe(d.summary):void 0;if(A&&!A.includes("<"))return{id:u,label:A,timing:{startTime:p,endTime:m}};try{let g=await this.getSession(d.sessionId,{readonly:!0},t),f=g?.object?g.object.sdkSession.getEvents().find(y=>y.type==="user.message")?.data.content:void 0;g?.dispose();let b=eXe(f??"");if(!b){this.logService.warn(`Copilot CLI session ${d.sessionId} has no user messages.`);return}return{id:u,label:b,timing:{startTime:p,endTime:m}}}catch(g){this.logService.warn(`Failed to load session ${d.sessionId}: ${g}`)}}))),s=new Set(o.map(d=>d.id)),c=Rn(Array.from(this._sessionWrappers.values()).filter(d=>!s.has(d.object.sessionId)).filter(d=>d.object.status===w2.InProgress).map(d=>{let u=eXe(d.object.pendingPrompt??"");if(u)return{id:d.object.sessionId,label:u,status:d.object.status,timing:{startTime:Date.now()}}}));return o.map(d=>({...d,status:this._sessionWrappers.get(d.id)?.object?.status})).concat(c)}catch(r){return this.logService.error(`Failed to get all sessions: ${r}`),[]}}async createSession({model:t,workingDirectory:r,isolationEnabled:a,agent:o},s){let c=await this.mcpHandler.loadMcpConfig(r),l=await this.createSessionsOptions({model:t,workingDirectory:r,isolationEnabled:a,mcpServers:c,agent:o}),d=await Pt(this.getSessionManager(),s),u=await d.createSession(l.toSessionOptions());return this.logService.trace(`[CopilotCLISession] Created new CopilotCLI session ${u.sessionId}.`),this._sessionTracker.trackSession(u.sessionId,"add"),this.createCopilotSession(u,l,d)}async createSessionsOptions(t){let r=await this.agents.getAgents();return new BIe({...t,customAgents:r},this.logService)}async getSession(t,{model:r,workingDirectory:a,isolationEnabled:o,readonly:s,agent:c},l){let d=this.sessionMutexForGetSession.get(t)??new tXe;this.sessionMutexForGetSession.set(t,d);let u=await d.acquire(l);if(!u||this._store.isDisposed||l.isCancellationRequested){u?.dispose();return}try{{let f=this._sessionWrappers.get(t);if(f)return this.logService.trace(`[CopilotCLISession] Reusing CopilotCLI session ${t}.`),f.acquire(),f}let[p,m]=await Promise.all([Pt(this.getSessionManager(),l),this.mcpHandler.loadMcpConfig(a)]),A=await this.createSessionsOptions({model:r,workingDirectory:a,agent:c,isolationEnabled:o,mcpServers:m}),g=await p.getSession({...A.toSessionOptions(),sessionId:t},!s);if(!g){this.logService.error(`[CopilotCLISession] CopilotCLI failed to get session ${t}.`);return}return this.createCopilotSession(g,A,p)}finally{u.dispose()}}createCopilotSession(t,r,a){let o=this.instantiationService.createInstance(Hj,r,t);o.add(o.onDidChangeStatus(()=>this._onDidChangeSessions.fire())),o.add(Pn(()=>{this._sessionWrappers.deleteAndLeak(t.sessionId),this.sessionMutexForGetSession.delete(t.sessionId),t.abort(),a.closeSession(t.sessionId)})),o.add(o.onDidChangeStatus(c=>{o.permissionRequested?this.sessionTerminators.deleteAndDispose(o.sessionId):o.status===void 0||o.status===w2.Completed||o.status===w2.Failed?this.sessionTerminators.set(o.sessionId,nF(()=>{o.dispose(),this.sessionTerminators.deleteAndDispose(o.sessionId)},akr)):this.sessionTerminators.deleteAndDispose(o.sessionId)}));let s=new nXe(o);return this._sessionWrappers.set(t.sessionId,s),s}async deleteSession(t){this._sessionTracker.trackSession(t,"delete");try{{let a=this._sessionWrappers.get(t);a&&(a.dispose(),this.logService.warn(`Delete an active session ${t}.`))}await(await this.getSessionManager()).deleteSession(t)}catch(r){this.logService.error(`Failed to delete session ${t}: ${r}`)}finally{this._sessionWrappers.deleteAndLeak(t),this._onDidChangeSessions.fire()}}};Zj=I([h(0,ne),h(1,eI),h(2,U),h(3,VR),h(4,Gt),h(5,n1e),h(6,X9)],Zj);var _ce=class{constructor(e,t,r){this.fileSystem=e;this.context=t;this.workspaceService=r;this._workspaceSessions=new Set;this._initializeSessionStorageFiles=new Xn(async()=>{let a=yC(this.context.globalStorageUri,"copilot.cli.oldGlobalSessions.json"),o=yC(this.context.globalStorageUri,"copilot.cli.workspaceSessions.json");if(this.workspaceService.getWorkspaceFolders().length){let s=this.context.workspaceState.get(Q$t);s||(s=`copilot.cli.workspaceSessions.${Dt()}.json`,await this.context.workspaceState.update(Q$t,s)),o=yC(this.context.globalStorageUri,s)}return await Promise.all([rve(this.fileSystem,this.context.globalStorageUri),(async()=>{let s=await this.fileSystem.readFile(a).then(c=>new TextDecoder().decode(c).split(",")).catch(()=>{});s&&(this._oldGlobalSessions=new Set(s))})(),(async()=>{(this.workspaceService.getWorkspaceFolders().length?await this.fileSystem.readFile(o).then(c=>new TextDecoder().decode(c).split(",")).catch(()=>[]):[]).forEach(c=>this._workspaceSessions.add(c))})()]),{global:a,workspace:o}}),this._initializeSessionStorageFiles.value}async initialize(e){let{global:t}=await this._initializeSessionStorageFiles.value;this._oldGlobalSessions||(this._oldGlobalSessions=new Set(e),this.fileSystem.writeFile(t,Buffer.from(e.join(","))))}async trackSession(e,t){if(this.workspaceService.getWorkspaceFolders().length===0)return;t==="add"?this._workspaceSessions.add(e):this._workspaceSessions.delete(e);let r=Array.from(this._workspaceSessions).join(","),{workspace:a}=await this._initializeSessionStorageFiles.value;this.fileSystem.writeFile(a,Buffer.from(r))}shouldShowSession(e){return this._oldGlobalSessions?.has(e)||this.workspaceService.getWorkspaceFolders().length===0?!0:this._workspaceSessions.has(e)}};_ce=I([h(0,Gt),h(1,wt),h(2,Qe)],_ce);function eXe(n){let t=VJe(n).split(`
`).find(r=>r.trim().length>0)??"";return t.length>50?t.substring(0,47)+"...":t}var tXe=class{constructor(){this._locked=!1;this._acquireQueue=[]}isLocked(){return this._locked}acquire(e){return Ca(new Promise(t=>{let r=()=>{if(e.isCancellationRequested){t(void 0);return}this._locked?this._acquireQueue.push(r):(this._locked=!0,t(Pn(()=>this._release())))};r()}),e)}_release(){if(!this._locked)throw new Error("Mutex: release called while not locked");this._locked=!1;let e=this._acquireQueue.shift();e&&e()}},nXe=class extends h0e{constructor(t){super(t);this.object=t}dispose(){this.release()}};var cs=require("vscode");var a1e=require("vscode");var lQ=class{constructor(){this._inFlightPromises=new Map}getOrCreate(e,t){let r=this._inFlightPromises.get(e);if(r)return r;let a=t().finally(()=>this._inFlightPromises.delete(e));return this._inFlightPromises.set(e,a),a}};function rXe(n){return N$t(n)||L$t(n)}function N$t(n){let e=["4535c7beffc844b46bb1ed4aa04d759a"];for(let t of n)if(e.includes(t))return!0;return!1}function L$t(n){let e=["a5db0bcaae94032fe715fb34a5e4bce2","7184f66dfcee98cb5f08a1cb936d5225","1cb18ac6eedd49b43d74a1c5beb0b955","ea9395b9a9248c05ee6847cbd24355ed"];for(let t of n)if(e.includes(t))return!0;return!1}var PT=class{constructor(e){this._info=e;this.tokenMap=this.parseToken(e.token)}parseToken(e){let t=new Map,a=e?.split(":")[0]?.split(";");for(let o of a){let[s,c]=o.split("=");t.set(s,c)}return t}get token(){return this._info.token}get sku(){return this._info.sku}get isIndividual(){return this._info.individual??!1}get organizationList(){return this._info.organization_list||[]}get enterpriseList(){return this._info.enterprise_list||[]}get endpoints(){return this._info.endpoints}get isInternal(){return rXe(this.organizationList)}get isMicrosoftInternal(){return L$t(this.organizationList)}get isGitHubInternal(){return N$t(this.organizationList)}get isFreeUser(){return this.sku==="free_limited_copilot"}get isNoAuthUser(){return this.sku==="no_auth_limited_copilot"}get isChatQuotaExceeded(){return this.isFreeUser&&(this._info.limited_user_quotas?.chat??1)<=0}get isCompletionsQuotaExceeded(){return this.isFreeUser&&(this._info.limited_user_quotas?.completions??1)<=0}get codeQuoteEnabled(){return this._info.code_quote_enabled??!1}get isVscodeTeamMember(){return this._info.isVscodeTeamMember}get codexAgentEnabled(){return this._info.codex_agent_enabled??!1}get copilotPlan(){if(this.isFreeUser)return"free";let e=this._info.copilot_plan;switch(e){case"individual":case"individual_pro":case"business":case"enterprise":return e;default:return"individual"}}get quotaInfo(){return{quota_snapshots:this._info.quota_snapshots,quota_reset_date:this._info.quota_reset_date}}get username(){return this._info.username}isTelemetryEnabled(){return this._isTelemetryEnabled===void 0&&(this._isTelemetryEnabled=this._info.telemetry==="enabled"),this._isTelemetryEnabled}isPublicSuggestionsEnabled(){return this._isPublicSuggestionsEnabled===void 0&&(this._isPublicSuggestionsEnabled=this._info.public_suggestions==="enabled"),this._isPublicSuggestionsEnabled}isChatEnabled(){return this._info.chat_enabled??!1}isCopilotIgnoreEnabled(){return this._info.copilotignore_enabled??!1}get isCopilotCodeReviewEnabled(){return this.getTokenValue("ccr")==="1"}isEditorPreviewFeaturesEnabled(){return this.getTokenValue("editor_preview_features")!=="0"}isMcpEnabled(){return this.getTokenValue("mcp")!=="0"}getTokenValue(e){return this.tokenMap.get(e)}isExpandedClientSideIndexingEnabled(){return this._info.blackbird_clientside_indexing===!0}isFcv1(){return this.tokenMap.get("fcv1")==="1"}};var QT=class extends d2{async getCurrentAuthedUserWithToken(e){return{avatar_url:"",login:"NullUser",name:"Null User"}}async getTeamMembershipWithToken(e,t,r){}async _makeGHAPIRequest(e,t,r,a){}};var M$t='Tests: either GITHUB_PAT, GITHUB_OAUTH_TOKEN, or GITHUB_OAUTH_TOKEN+VSCODE_COPILOT_CHAT_TOKEN must be set unless running from an IS_SCENARIO_AUTOMATION environment. Run "npm run get_token" to get credentials.';function iXe(){let n=process.env.GITHUB_PAT,e=process.env.GITHUB_OAUTH_TOKEN;if(!(Ro&&!n&&!e))return()=>{if(n)return n;if(e)return e;throw new Error(M$t)}}function F$t(n){if(process.env.VSCODE_COPILOT_CHAT_TOKEN)return new je(Cce,[process.env.VSCODE_COPILOT_CHAT_TOKEN]);if(process.env.GITHUB_OAUTH_TOKEN)return new je(Ece,[process.env.GITHUB_OAUTH_TOKEN]);if(process.env.GITHUB_PAT)return new je(vce,[process.env.GITHUB_PAT]);if(Ro)return new je(wce,[n]);throw new Error(M$t)}var y3=class extends pe{constructor(t,r,a,o,s,c,l){super();this._baseOctokitservice=t;this._logService=r;this._telemetryService=a;this._domainService=o;this._capiClientService=s;this._fetcherService=c;this._envService=l;this._isDisposed=!1;this._copilotTokenRefreshEmitter=this._register(new Lt);this.onDidCopilotTokenRefresh=this._copilotTokenRefreshEmitter.event;this._register(Pn(()=>this._isDisposed=!0))}get copilotToken(){return this._copilotToken}set copilotToken(t){t!==this._copilotToken&&(this._copilotToken=t,this._copilotTokenRefreshEmitter.fire())}resetCopilotToken(t){t!==void 0&&this._telemetryService.sendGHTelemetryEvent("auth.reset_token_"+t),this._logService.debug(`Resetting copilot token on HTTP error ${t||"unknown"}`),this.copilotToken=void 0}async authFromGitHubToken(t,r){return this.doAuthFromGitHubTokenOrDevDeviceId({githubToken:t,ghUsername:r})}async authFromDevDeviceId(t){return this.doAuthFromGitHubTokenOrDevDeviceId({devDeviceId:t})}async doAuthFromGitHubTokenOrDevDeviceId(t){this._telemetryService.sendGHTelemetryEvent("auth.new_login");let r,a,o;if("githubToken"in t?(o=t.ghUsername,[r,a]=await Promise.all([this.fetchCopilotTokenFromGitHubToken(t.githubToken),this.fetchCopilotUserInfo(t.githubToken)])):r=await this.fetchCopilotTokenFromDevDeviceId(t.devDeviceId),!r)return this._logService.warn("Failed to get copilot token"),this._telemetryService.sendGHTelemetryErrorEvent("auth.request_failed"),{kind:"failure",reason:"RequestFailed"};let s=await pDt(r);if(!s)return this._logService.warn("Failed to get copilot token"),this._telemetryService.sendGHTelemetryErrorEvent("auth.request_read_failed"),{kind:"failure",reason:"ParseFailed"};if(r.status===401)return this._logService.warn("Failed to get copilot token due to 401 status"),this._telemetryService.sendGHTelemetryErrorEvent("auth.unknown_401"),{kind:"failure",reason:"HTTP401"};if(r.status===403&&s.message?.startsWith("API rate limit exceeded"))return this._logService.warn("Failed to get copilot token due to exceeding API rate limit"),this._telemetryService.sendGHTelemetryErrorEvent("auth.rate_limited"),{kind:"failure",reason:"RateLimited"};if(!r.ok||!s.token){this._logService.warn(`Invalid copilot token: missing token: ${r.status} ${r.statusText}`);let m=ws.createAndMarkAsIssued({status:r.status.toString(),status_text:r.statusText});return this._telemetryService.sendGHTelemetryErrorEvent("auth.invalid_token",m.properties,m.measurements),{kind:"failure",reason:"NotAuthorized",...s.error_details}}let c=s.expires_at;s.expires_at=_F()+s.refresh_in+60;let l=o??"unknown",d=!1;rXe(s.organization_list??[])&&"githubToken"in t&&(d=!!await this._baseOctokitservice.getTeamMembershipWithToken(aDt,t.githubToken,l));let u={...s,copilot_plan:a?.copilot_plan??s.sku??"",quota_snapshots:a?.quota_snapshots,quota_reset_date:a?.quota_reset_date,codex_agent_enabled:a?.codex_agent_enabled,username:l,isVscodeTeamMember:d},p=ws.createAndMarkAsIssued({},{adjusted_expires_at:s.expires_at,expires_at:c,current_time:_F()});return this._telemetryService.sendGHTelemetryEvent("auth.new_token",p.properties,p.measurements),{kind:"success",...u}}async fetchCopilotTokenFromGitHubToken(t){let r={headers:{Authorization:`token ${t}`,"X-GitHub-Api-Version":"2025-04-01"},retryFallbacks:!0,expectJSON:!0};return await this._capiClientService.makeRequest(r,{type:zn.CopilotToken})}async fetchCopilotTokenFromDevDeviceId(t){let r={headers:{"X-GitHub-Api-Version":"2025-04-01","Editor-Device-Id":`${t}`},retryFallbacks:!0,expectJSON:!0};return await this._capiClientService.makeRequest(r,{type:zn.CopilotNLToken})}async fetchCopilotUserInfo(t){let r={headers:{Authorization:`token ${t}`,"X-GitHub-Api-Version":"2025-04-01"},retryFallbacks:!0,expectJSON:!0};return await(await this._capiClientService.makeRequest(r,{type:zn.CopilotUserInfo})).json()}},vce=class extends y3{constructor(t,r,a,o,s,c,l){super(new QT(o,c,r,a),r,a,s,o,c,l);this._completionsToken=t;this.copilotToken={token:t,expires_at:0,refresh_in:0,username:"fixedTokenManager",isVscodeTeamMember:!1,copilot_plan:"unknown"}}set completionsToken(t){this._completionsToken=t,this.copilotToken={token:t,expires_at:0,refresh_in:0,username:"fixedTokenManager",isVscodeTeamMember:!1,copilot_plan:"unknown"}}get completionsToken(){return this._completionsToken}async getCopilotToken(){return new PT(this.copilotToken)}async checkCopilotToken(){return{status:"OK"}}};vce=I([h(1,ne),h(2,Te),h(3,Qn),h(4,Qo),h(5,cn),h(6,Rt)],vce);var Cce=class extends y3{constructor(e,t,r,a,o,s,c){super(new QT(a,s,t,r),t,r,o,a,s,c);let l=Buffer.from(e,"base64").toString("utf8");this._initialToken=JSON.parse(l)}async getCopilotToken(){return this.copilotToken||(this.copilotToken={...this._initialToken}),new PT(this._initialToken)}async checkCopilotToken(){return{status:"OK"}}};Cce=I([h(1,ne),h(2,Te),h(3,Qn),h(4,Qo),h(5,cn),h(6,Rt)],Cce);var r1e=class extends y3{async getCopilotToken(e){if(!this.copilotToken||this.copilotToken.expires_at<_F()-60*5||e){let t=await this.authenticateAndGetToken();if(t.kind==="failure")throw Error(`Failed to get copilot token: ${t.reason.toString()} ${t.message??""}`);this.copilotToken={...t}}return new PT(this.copilotToken)}async checkCopilotToken(){if(!this.copilotToken||this.copilotToken.expires_at<_F()){let t=await this.authenticateAndGetToken();if(t.kind==="failure")return t;this.copilotToken={...t}}return{status:"OK"}}},wce=class extends r1e{constructor(t,r,a,o,s,c,l,d){super(new QT(s,c,r,a),r,a,o,s,c,l);this.deviceId=t;this.configurationService=d}async authenticateAndGetToken(){return this.authFromDevDeviceId(this.deviceId)}};wce=I([h(1,ne),h(2,Te),h(3,Qo),h(4,Qn),h(5,cn),h(6,Rt),h(7,Ce)],wce);var Ece=class extends r1e{constructor(t,r,a,o,s,c,l,d,u){super(new QT(c,l,a,o),a,o,s,c,l,d);this.githubToken=t;this.githubUsername=r;this.configurationService=u}async authenticateAndGetToken(){return this.authFromGitHubToken(this.githubToken,this.githubUsername)}};Ece=I([h(2,ne),h(3,Te),h(4,Qo),h(5,Qn),h(6,cn),h(7,Rt),h(8,Ce)],Ece);var gI=require("vscode");var O$t="You are not signed in to GitHub. Please sign in to use Copilot.";async function U$t(n,e,t,r={}){if(!(await gI.authentication.getAccounts(n)).length)return await gI.authentication.getSession(n,e,r);if(r.forceNewSession)return await gI.authentication.getSession(n,e,{...r,forceNewSession:tS({learnMore:_e.parse("https://aka.ms/copilotRepoScope")},r.forceNewSession),clearSessionPreference:!0});let o=await t();return o||(r.createIfNone?await gI.authentication.getSession(n,e,{forceNewSession:{learnMore:_e.parse("https://aka.ms/copilotRepoScope")},clearSessionPreference:!0}):await gI.authentication.getSession(n,e,r))}function i1e(n,e){let t=vF(n);return U$t(t,Pie,async()=>{if(n.getConfig(V.Shared.AuthPermissions)!=="minimal"){let o=await gI.authentication.getSession(t,nq,{silent:!0});if(o)return o}let r=await gI.authentication.getSession(t,Pie,{silent:!0});if(r)return r;let a=await gI.authentication.getSession(t,cDt,{silent:!0});if(a)return a},e)}function q$t(n,e){if(n.getConfig(V.Shared.AuthPermissions)==="minimal"){if(e.createIfNone||e.forceNewSession)throw new p2;return Promise.resolve(void 0)}let t=vF(n);return U$t(t,nq,async()=>await gI.authentication.getSession(t,nq,{silent:!0}),e)}var $$t=!1,xce=class extends Error{},Ice=class extends Error{},kce=class extends Error{},Sce=class extends Error{},Tce=class extends Error{},Vj=class extends y3{constructor(t,r,a,o,s,c,l){super(new d2(o,s,t,r),t,r,a,o,s,c);this.configurationService=l;this._taskSingler=new lQ}async getCopilotToken(t){if(!this.copilotToken||this.copilotToken.expires_at-60*5<_F()||t)try{this._logService.debug(`Getting CopilotToken (force: ${t})...`),this.copilotToken=await this._authShowWarnings(),this._logService.debug(`Got CopilotToken (force: ${t}).`)}catch(r){throw this._logService.debug(`Getting CopilotToken (force: ${t}) threw error: ${r}`),this.copilotToken=void 0,r}return new PT(this.copilotToken)}async _auth(){let t=this.configurationService.getNonExtensionConfig("chat.allowAnonymousAccess"),r=await i1e(this.configurationService,{silent:!0});if(!r&&!t)return this._logService.warn("GitHub login failed"),this._telemetryService.sendGHTelemetryErrorEvent("auth.github_login_failed"),{kind:"failure",reason:"GitHubLoginFailed"};if(r){this._logService.info(`Logged in as ${r.account.label}`);let a=await this.authFromGitHubToken(r.accessToken,r.account.label);return a.kind==="success"&&(this._logService.info(`Got Copilot token for ${r.account.label}`),this._logService.info(`Copilot Chat: ${this._envService.getVersion()}, VS Code: ${this._envService.vscodeVersion}`)),a}else{this._logService.info("Allowing anonymous access with devDeviceId");let a=await this.authFromDevDeviceId(a1e.env.devDeviceId);if(a.kind==="success")this._logService.info("Got Copilot token for devDeviceId"),this._logService.info(`Copilot Chat: ${this._envService.getVersion()}, VS Code: ${this._envService.vscodeVersion}`);else return this._logService.warn("GitHub login failed"),{kind:"failure",reason:"GitHubLoginFailed"};return a}}async _authShowWarnings(){let t=await this._taskSingler.getOrCreate("auth",()=>this._auth());if(this.sendTokenResultErrorTelemetry(t),t.kind==="failure"&&t.reason==="NotAuthorized"){let r=t.message;switch(t.notification_id){case"not_signed_up":case"no_copilot_access":throw new xce(r??"User not authorized");case"subscription_ended":throw new Ice(r);case"enterprise_managed_user_account":throw new Sce(r);case"server_error":case"feature_flag_blocked":case"spammy_user":case"snippy_not_configured":throw new kce(r)}}if(t.kind==="failure"&&t.reason==="HTTP401"){let r="Your GitHub token is invalid. Please sign out from your GitHub account using the VS Code accounts menu and try again.";throw $$t||($$t=!0,a1e.window.showWarningMessage(r)),Error(r)}if(t.kind==="failure"&&t.reason==="GitHubLoginFailed")throw Error("GitHubLoginFailed");if(t.kind==="failure"&&t.reason==="RateLimited")throw Error("Your account has exceeded GitHub's API rate limit. Please try again later.");if(t.kind==="failure")throw Error("Failed to get copilot token. reason: "+t.reason);if(t.kind==="success"&&t.chat_enabled===!1)throw new Tce("Copilot Chat is disabled");return t}sendTokenResultErrorTelemetry(t){t.kind!=="success"&&this._telemetryService.sendMSFTTelemetryEvent("copilotTokenFetching.error",{reason:t.reason,notification_id:t.notification_id})}};Vj=I([h(0,ne),h(1,Te),h(2,Qo),h(3,Qn),h(4,cn),h(5,Rt),h(6,Ce)],Vj);var jA=j(require("vscode"));var Ia=de("IGitExtensionService");var fI=j(require("vscode"));var Yj=29950,aXe=fI.l10n.t("Continue with truncation"),z$t=fI.l10n.t("Created from [VS Code](https://code.visualstudio.com/docs/copilot/copilot-coding-agent)."),j$t="v1";function G$t(n,e,t){if(e.length>=Yj)return n.warn(`Truncation: Prompt length ${e.length} exceeds max of ${Yj}`),e=e.slice(-Yj),{problemStatement:e,isTruncated:!0};if(t&&e.length+t.length>=Yj){let r=Yj-e.length-2;return n.warn(`Truncation: Combined prompt and context length ${e.length+t.length} exceeds max of ${Yj}`),t=t.slice(-r),{problemStatement:e+(t?`

${t}`:""),isTruncated:!0}}return{problemStatement:e+(t?`
