/**
 * Player response extraction from YouTube pages
 */

import { throwExtractionFailed, throwVideoNotFound, throwVideoPrivate, throwRateLimited } from '../utils/errors';

export interface VideoDetails {
  videoId: string;
  title: string;
  lengthSeconds: number;
  thumbnails: Thumbnail[];
  author: string;
  channelId: string;
  shortDescription: string;
  viewCount: number;
  isLive: boolean;
  isPrivate: boolean;
}

export interface Thumbnail {
  url: string;
  width: number;
  height: number;
}

export interface Format {
  itag: number;
  url?: string;
  signatureCipher?: string;
  mimeType: string;
  bitrate: number;
  width?: number;
  height?: number;
  quality: string;
  qualityLabel?: string;
  audioQuality?: string;
  audioSampleRate?: string;
  audioChannels?: number;
  fps?: number;
  hasVideo: boolean;
  hasAudio: boolean;
  contentLength?: string;
}

export interface CaptionTrack {
  baseUrl: string;
  languageCode: string;
  name: string;
  isAutoGenerated: boolean;
  isTranslatable: boolean;
}

export interface PlayerResponse {
  videoDetails: VideoDetails;
  formats: Format[];
  adaptiveFormats: Format[];
  captionTracks: CaptionTrack[];
  playerJsUrl: string;
  expiresInSeconds: number;
}

/**
 * Fetch a YouTube page with optional cookies
 */
export async function fetchYouTubePage(
  url: string,
  cookies?: string
): Promise<Response> {
  const headers: HeadersInit = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
    'Accept-Language': 'en-US,en;q=0.5',
    'Accept-Encoding': 'gzip, deflate, br',
  };

  if (cookies) {
    headers['Cookie'] = cookies;
  }

  const response = await fetch(url, { headers });

  if (response.status === 429) {
    throwRateLimited();
  }

  return response;
}

/**
 * Extract ytInitialPlayerResponse from YouTube page HTML
 */
export function extractPlayerResponseFromHtml(html: string): any {
  // Try multiple patterns
  const patterns = [
    /var\s+ytInitialPlayerResponse\s*=\s*(\{.+?\});/s,
    /ytInitialPlayerResponse\s*=\s*(\{.+?\})\s*;/s,
    /window\["ytInitialPlayerResponse"\]\s*=\s*(\{.+?\});/s,
  ];

  for (const pattern of patterns) {
    const match = html.match(pattern);
    if (match) {
      try {
        // Find the end of the JSON object properly
        const jsonStr = extractBalancedJson(match[1]);
        return JSON.parse(jsonStr);
      } catch (e) {
        continue;
      }
    }
  }

  throwExtractionFailed('Could not find playerResponse in page');
}

/**
 * Extract a balanced JSON object from a string that might have trailing content
 */
function extractBalancedJson(str: string): string {
  let depth = 0;
  let inString = false;
  let escape = false;

  for (let i = 0; i < str.length; i++) {
    const char = str[i];

    if (escape) {
      escape = false;
      continue;
    }

    if (char === '\\' && inString) {
      escape = true;
      continue;
    }

    if (char === '"' && !escape) {
      inString = !inString;
      continue;
    }

    if (!inString) {
      if (char === '{') depth++;
      if (char === '}') {
        depth--;
        if (depth === 0) {
          return str.substring(0, i + 1);
        }
      }
    }
  }

  return str;
}

/**
 * Extract player JS URL from page
 */
export function extractPlayerJsUrl(html: string): string {
  const patterns = [
    /"jsUrl":"(\/s\/player\/[^"]+\/base\.js)"/,
    /"PLAYER_JS_URL":"([^"]+)"/,
    /\/s\/player\/([a-zA-Z0-9]+)\/player_ias[^"]+\.js/,
  ];

  for (const pattern of patterns) {
    const match = html.match(pattern);
    if (match) {
      let url = match[1] || match[0];
      if (!url.startsWith('http')) {
        url = 'https://www.youtube.com' + url;
      }
      return url;
    }
  }

  throwExtractionFailed('Could not find player JS URL');
}

/**
 * Parse raw playerResponse into structured data
 */
export function parsePlayerResponse(raw: any): PlayerResponse {
  // Check for errors
  if (raw.playabilityStatus?.status === 'ERROR') {
    throwVideoNotFound();
  }

  if (raw.playabilityStatus?.status === 'LOGIN_REQUIRED') {
    throwVideoPrivate();
  }

  if (raw.playabilityStatus?.status === 'UNPLAYABLE') {
    const reason = raw.playabilityStatus?.reason || 'Video is unavailable';
    throwExtractionFailed(reason);
  }

  const videoDetails = raw.videoDetails;
  if (!videoDetails) {
    throwExtractionFailed('No video details found');
  }

  const streamingData = raw.streamingData || {};
  const captions = raw.captions?.playerCaptionsTracklistRenderer?.captionTracks || [];

  const parseFormat = (f: any): Format => ({
    itag: f.itag,
    url: f.url,
    signatureCipher: f.signatureCipher || f.cipher,
    mimeType: f.mimeType,
    bitrate: f.bitrate,
    width: f.width,
    height: f.height,
    quality: f.quality,
    qualityLabel: f.qualityLabel,
    audioQuality: f.audioQuality,
    audioSampleRate: f.audioSampleRate,
    audioChannels: f.audioChannels,
    fps: f.fps,
    hasVideo: !!f.width,
    hasAudio: !!f.audioQuality || !!f.audioSampleRate,
    contentLength: f.contentLength,
  });

  return {
    videoDetails: {
      videoId: videoDetails.videoId,
      title: videoDetails.title,
      lengthSeconds: parseInt(videoDetails.lengthSeconds, 10),
      thumbnails: videoDetails.thumbnail?.thumbnails || [],
      author: videoDetails.author,
      channelId: videoDetails.channelId,
      shortDescription: videoDetails.shortDescription,
      viewCount: parseInt(videoDetails.viewCount, 10),
      isLive: videoDetails.isLive || false,
      isPrivate: videoDetails.isPrivate || false,
    },
    formats: (streamingData.formats || []).map(parseFormat),
    adaptiveFormats: (streamingData.adaptiveFormats || []).map(parseFormat),
    captionTracks: captions.map((c: any) => ({
      baseUrl: c.baseUrl,
      languageCode: c.languageCode,
      name: c.name?.simpleText || c.name?.runs?.[0]?.text || c.languageCode,
      isAutoGenerated: c.kind === 'asr',
      isTranslatable: c.isTranslatable || false,
    })),
    playerJsUrl: '', // Will be set separately
    expiresInSeconds: parseInt(streamingData.expiresInSeconds, 10) || 0,
  };
}

/**
 * Full extraction flow for a video
 */
export async function extractVideoData(
  videoId: string,
  cookies?: string
): Promise<{ playerResponse: PlayerResponse; html: string }> {
  const url = `https://www.youtube.com/watch?v=${videoId}`;
  const response = await fetchYouTubePage(url, cookies);
  const html = await response.text();

  const rawPlayerResponse = extractPlayerResponseFromHtml(html);
  const playerResponse = parsePlayerResponse(rawPlayerResponse);
  
  // Extract and set player JS URL
  playerResponse.playerJsUrl = extractPlayerJsUrl(html);

  return { playerResponse, html };
}
