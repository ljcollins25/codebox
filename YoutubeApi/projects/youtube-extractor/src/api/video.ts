/**
 * API endpoint: /api/video
 */

import type { Env } from '../index';
import { extractToken, validateToken } from '../auth/login';
import { extractVideoData } from '../extraction/player';
import { processFormats, getRecommendedFormats, type ProcessedFormat } from '../extraction/formats';
import { updateToken } from '../storage/kv';
import { throwInvalidParams, throwMissingAuth } from '../utils/errors';

export async function handleApiVideo(
  request: Request,
  env: Env
): Promise<Response> {
  // Extract and validate token
  const token = extractToken(request);
  if (!token) {
    throwMissingAuth();
  }
  
  const tokenData = await validateToken(env, token);
  
  // Parse query params
  const url = new URL(request.url);
  const videoId = url.searchParams.get('v');
  
  if (!videoId) {
    throwInvalidParams('Video ID (v) is required');
  }
  
  // Extract video data
  const { playerResponse } = await extractVideoData(videoId, tokenData.youtube_cookies);
  
  // Process formats (decipher signatures, apply n-transform)
  const processedFormats = await processFormats(env, playerResponse);
  
  // Update last_used
  await updateToken(env, token, { last_used: new Date().toISOString() });
  
  // Get recommended format combination
  const recommended = getRecommendedFormats(processedFormats);
  
  // Build response
  const response = {
    video_id: videoId,
    title: playerResponse.videoDetails.title,
    duration_seconds: playerResponse.videoDetails.lengthSeconds,
    thumbnail: playerResponse.videoDetails.thumbnails[
      playerResponse.videoDetails.thumbnails.length - 1
    ]?.url || null,
    author: playerResponse.videoDetails.author,
    channel_id: playerResponse.videoDetails.channelId,
    view_count: playerResponse.videoDetails.viewCount,
    description: playerResponse.videoDetails.shortDescription,
    is_live: playerResponse.videoDetails.isLive,
    formats: processedFormats.map(formatToResponse),
    recommended: {
      video_itag: recommended.video?.itag || recommended.combined?.itag || null,
      audio_itag: recommended.audio?.itag || null,
      needs_muxing: recommended.needsMuxing,
    },
    subtitles: playerResponse.captionTracks.map(track => ({
      code: track.languageCode,
      name: track.name,
      auto: track.isAutoGenerated,
    })),
  };
  
  return new Response(JSON.stringify(response), {
    headers: { 'Content-Type': 'application/json' },
  });
}

function formatToResponse(format: ProcessedFormat) {
  return {
    itag: format.itag,
    quality: format.qualityLabel || format.quality,
    mime_type: format.mimeType,
    has_video: format.hasVideo,
    has_audio: format.hasAudio,
    width: format.width,
    height: format.height,
    fps: format.fps,
    bitrate: format.bitrate,
    audio_quality: format.audioQuality,
    url: format.url,
  };
}
